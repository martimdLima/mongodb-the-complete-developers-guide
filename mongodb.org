#+TITLE:     MongoDB - The Complete Guide
#+AUTHOR:    Martim Lima
#+EMAIL:     (concat "martim.d.lima" at-sign "protonmail.com")
#+DATE:      10-10-2020
#+LANGUAGE:  en
#+OPTIONS:   H:4 num:nil toc:2

#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

#+begin_export html
<div class="right">
  <a href="https://github.com/fniessen/org-html-themes/blob/master/demo/example.org" class="fa fa-github"> Edit on GitHub</a>
</div>
#+end_export

-----

* Basics & Crud Operations :basics:
  :PROPERTIES:
  :CATEGORY: Basics
  :END:

An overview of the basics of mongodb and crud operations

** Check databases / Create a Database
   :PROPERTIES:
   :CATEGORY: databases
   :END:

#+BEGIN_SRC javascript
// Show all databases
>  show dbs

// Use the specified database
> use dbname
#+END_SRC


** Create a document

#+BEGIN_SRC javascript
// Create a Document
> db.dbname.insertOne(
    {name: "product1", price: 12.99}
)

// Create a document with an embbeded document
> db.dbname.insertOne(
    {
        key1: "dummy",
        key2: 12.99,
        key3: "A dummy product",
        key4: {
            key4subkey1: "key4subval1",
            key4subkey1: key4subkey2
            }
    }
)

// Create various documents in a collection
> db.dbname.insertMany(
    [
        {
            key1: "value1",
            key2: "value2",
            key3: "value3",
            key4: "value4",
        },
        {
            key1: "value1",
            key2: "value2",
            key3: "value3",
            key4: "value4",
        }
    ]
)

#+END_SRC

** Find documents

find() doesn't return an array of all the documents in a collection, but a cursor pretty() can only be applied when the result of the operation applied returns a cursor while find() returns a cursor, findOne() returns a document, so it can only be applied to find().


#+BEGIN_SRC javascript
// Find all documents in a collection
> db.dbname.find()

// Find all documents in a collection in a prettified form
> db.dbname.find().pretty()

// Find all documents in a collection and convert it to array (This operation returns every document in a collection, despite the size)
> db.dbname.find().toArray()

// Find all documents in a collection and apply certain operations on each one
> db.dbname.find().forEach((colData) => {printjson(colData)})

// Find all documents in a collection that match a specific key/value
> db.dbname.find({key: value})

// Find all documents in a collection that are greater than the specificied key/value
> db.dbname.find({key: {$gt: value}})

// Find one document in a collection that match a specific key/value
> db.dbname.findOne({key: value})

// Find all documents in a collection that is greater than the specific key/value
> db.dbname.findOne({key: {$gt: value}})
#+END_SRC


** Update Documents

#+BEGIN_SRC javascript
// Update one document
> db.dbname.updateOne({key: "value"}, {$set: {key: "updtValue"}})

// Update many documents
> db.dbname.updateMany({}, {$set: {key: "updtValue"}})

// Update a document replacing all key/value pairs
> db.dbname.update({key: "value"}, {{key: "updtValue"}})i
#+END_SRC


** Replace Documents

#+BEGIN_SRC javascript
// Replace a document
> db.dbname.replaceOne(  {
    key1: "value1",
    key2: "value2",
    key3: "value3",
    key4: "value4",
  })
#+END_SRC


** Delete Documents

#+BEGIN_SRC javascript
// Delete one document
> db.dbname.deleteOne({key: "value"})

// Delete all documents that have common key/pair values
> db.dbname.deleteMany({commonKey: "commonValue"})

// Delete many documents
> db.dbname.deleteMany({})
#+END_SRC


** Projections

#+BEGIN_SRC
// Using projections to return all the documents with the choosen properties
> db.dbname.find({}, {key: value}).pretty()

// Using projections to return all the documents in the collection with the choosen properties, excluding some
> db.dbname.find({}, {key: value, _key: value}).pretty()
#+END_SRC


** Working with nested documents

#+BEGIN_SRC
// Update a document with a nested document
> db.dbname.updateMany({}, {$set: {key: {nestedKey1: "nestedValue1", nestedKey2: "nestedValue2"}}})

// Update a document with a nested document
> db.dbname.updateMany({}, {$set: {key: {nKey1: "nVal1", nKey2: "nVal2", nK3: {nk3a: "nk3aVal"}}}})
#+END_SRC


** Working with arrays

#+BEGIN_SRC
> db.dbname.updateOne({key: "val"}, {$set: {newKey: ["val1", "val2"]}})
#+END_SRC


** Acessing structured data

#+BEGIN_SRC
// Acessing a specific field of a document
 > db.dbname.findOne({key: "val"}).key2

// Searching for documents with a specific field
 > db.dbname.find({key: "value"}).pretty()

// Searching for documents that have a field with a specific subfield and value present
 > db.dbname.find({"key.subkey": "subkeyVal"}).pretty()

// Searching for documents that have a field that has a subfield with a specific subfield and value present
 > db.dbname.find({"key.subkey.subsubkey": "subsubkeyVal"}).pretty()
#+END_SRC


-----

* Schemas & Relations - How to Structure Documents :schemasandrelations:
  :PROPERTIES:
  :CATEGORY: Schemas & Relations
  :END:

** Structuring documents

#+BEGIN_SRC javascript
 > db.colname.insertMany([
  {
    name: "Dummy1",
    price: 12.99,
    details: null
  },
  {
    name: "Dummy1",
    price: 1234,
    details: null
  },
  {
    name: "Dummy3",
    price: 29.99,
    details: {name: "nestedDummy"}
  }
])
#+END_SRC

** Data Types

#+BEGIN_SRC javascript
> db.colname.insertOne(
    {
      name: "Dummy Corp Inc",
      isStartup: true,
      employees: 35,
      funding: 01234567899876543210,
      details: {ceo: "Dummy CEO"},
      tags: [{title: "test1"}, {title: "teste2"}],
      foundingDate: new Date(),
      insertedAt: new Timestamp()
    }
)
#+END_SRC

** Database Stats

#+BEGIN_SRC javascript
> db.stats()
#+END_SRC

** Check the type of an value

#+BEGIN_SRC javascript
> typeof db.colname.findOne().key
#+END_SRC

** Insert a document with a number with a default 64 bit value

#+BEGIN_SRC javascript
> db.colname.insertOne({key: 1})
#+END_SRC

** Insert a product with a number with an int32 value instead of 64 bit

#+BEGIN_SRC javascript
> db.colname.insertOne({key: NumberInt(1)})
#+END_SRC

** Important data type limits

+ *Normal integers (int32)* can hold a maximum value of +-2,147,483,647

+ *Long integers (int64)* can hold a maximum value of +-9,223,372,036,854,775,807

+ *Text* can be as long as you want - the limit is the 16mb restriction for the overall document

It's also important to understand the difference between int32 (NumberInt), int64 (NumberLong) and a normal number as you can enter it in the shell.
The same goes for a normal double and NumberDecimal.

+ *NumberInt* creates a int32 value => NumberInt(55)

+ *NumberLong* creates a int64 value => NumberLong(7489729384792)

If you just use a number (e.g. insertOne({a: 1}), this will get added as a normal double into the database.
The reason for this is that the shell is based on JS which only knows float/ double values and doesn't differ between integers and floats.

+  *NumberDecimal* creates a high-precision double value => NumberDecimal("12.99") => This can be helpful for cases where you need (many) exact decimal places for calculations.

When not working with the shell but a MongoDB driver for your app programming language (e.g. PHP, .NET, Node.js, ...), you can use the driver to create these specific numbers.

* Exploring the Shell and the Server


* Create Operations :createOperations:
 :PROPERTIES:
  :CATEGORY: Understanding create Operations
  :END:

** insert() Methods

#+begin_src javascript

#+end_src


*** unordered inserts

#+BEGIN_SRC javascript
> use contactData

> db.persons.insertOne(
    {
        name: "dummy",
        age: 30,
        hobbies: ["Sports", "Cooking"]
    }
)

> db.persons.insertOne(
    {
        name: "dummy2",
        age: 35,
        hobbies: ["Music", "Cinema"]
    }
)

> db.persons.insertMany(
    [
        {
            name: "dummy4",
            age: 18,
        },
                {
            name: "dummy4",
            age: 39,
        },
    ]
)

> db.persons.insert(
        {
            name: "dummy5",
            age: 18,
        }
)
#+END_SRC

*** ordered inserts

#+BEGIN_SRC javascript
> db.hobbies.insertMany(
    [
        {_id: "sports", name: "Sports"},
        {_id: "cooking", name: "Cooking"},
        {_id: "cars", name: "Cars"},
    ]
)
#+END_SRC

As it is the default behaviour of mongoDB, if we try to insert a value already added before, it will cancel the operation and output an error,
but since mongoDB by defaul treats each operation as standalone, it will insert the first value and cancel the others inserts when it gets to the second element.

#+begin_src javascript
> db.hobbies.insertMany(
    [
        {_id: "astronomy", name: "astronomy"},
        {_id: "cooking", name: "Cooking"},
        {_id: "hiking", name: "Hiking"},
    ]
)
#+end_src

To override this behaviour, we can pass a second argument to insertMany().
This second argument is a document used to configure this operation.
In this case, it will fail the first two values and insert the last two values.

#+begin_src javascript
> db.hobbies.insertMany(
    [
        {_id: "sports", name: "Sports"},
        {_id: "cooking", name: "Cooking"},
        {_id: "astronomy", name: "astronomy"},
        {_id: "hiking", name: "Hiking"},
    ],
    {ordered: false}
)
#+end_src



** writeConcern

Write concern describes the level of acknowledgment requested from MongoDB for write operations to a standalone mongod or to replica sets or to sharded clusters.
In sharded clusters, mongos instances will pass the write concern on to the shards.

Starting in MongoDB 4.4, replica sets and sharded clusters support setting a global default write concern.
Operations which do not specify an explicit write concern inherit the global default write concern settings.

#+BEGIN_SRC javascript
// w can be set to either 1 or 0, for server acknowledgment.
> db.persons.insertOne(
    {
        name: "dummy6",
        age: 38,
    },
    {
        writeConcern: {w: 1}
    }
)

// j can be set to either true or false, to trigger jornaling of the entry
> db.persons.insertOne(
    {
        name: "dummy7",
        age: 38,
    },
    {
        writeConcern: {w: 1, j: true}
    }
)

// wtimeout can be set to the timeout of the write operation
> db.persons.insertOne(
    {
        name: "dummy7",
        age: 38,
    },
    {
        writeConcern: {w: 1, j: true, wtimeout: 2000}
    }
)
#+END_SRC


** Atomicity

In MongoDB, a write operation is atomic on the level of a single document,
even if the operation modifies multiple embedded documents within a single document.

** Multi-Document Transactions

When a single write operation (e.g. db.collection.updateMany()) modifies multiple documents,
the modification of each document is atomic, but the operation as a whole is not atomic.

When performing multi-document write operations, whether through a single write operation or multiple write operations, other operations may interleave.

** Importing Data

in the terminal shell

#+BEGIN_SRC shell
mongoimport tv-shows.json -d movieData -c movies --jsonArray --drop
#+END_SRC


* Read Operations :readOperations:
 :PROPERTIES:
  :CATEGORY: Understanding read Operations
  :END:


* Update Operations :updateOperations:
 :PROPERTIES:
  :CATEGORY: Understanding update Operations
  :END:


* Delete Operations :deleteOperations:
 :PROPERTIES:
  :CATEGORY: Understanding delete Operations
  :END:



* Indexes :indexes:
 :PROPERTIES:
  :CATEGORY: Indexes
  :END:


* GeoSpatial Data :geospatialData:
 :PROPERTIES:
  :CATEGORY: GeoSpatil Data and Operations
  :END:


* Numeric Data :numericData:
 :PROPERTIES:
  :CATEGORY: Numeric Data
  :END:


* Aggregation Framework :aggregationFramework:
 :PROPERTIES:
  :CATEGORY: Aggregation Framework
  :END:




* MongoDB & Securtiy :security:
 :PROPERTIES:
  :CATEGORY: Working with mongoDB
  :END:


* Performance, Fault Tolerancy & Deployment :performanceAndDeployment:
 :PROPERTIES:
  :CATEGORY: Performance, Fault Tolerancy and Deployment
  :END:


* Transactions :transactions:
 :PROPERTIES:
  :CATEGORY: Transactions in MongoDB
  :END:


* Introduction to Stitch :stitch:
 :PROPERTIES:
  :CATEGORY: Introduciton to Stitch
  :END:


* Useful Resources and Links :resourcesAndLinks:
